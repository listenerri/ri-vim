"##########
" ultisnips
" 快速插入代码片段
" 会在ycm弹出的补全菜单中包含又<snip>字样的补全项
" 这些补全项可以插入一段代码,要插入这种补全项需要输入这一项在补全菜单中的完整文字,
" 或者使用上面ycm定义的上下移动键移动到要使用的代码段,然后按<tab>键,即可展开片段
" 代码引擎
Plug 'SirVer/ultisnips'
" 代码片段
Plug 'honza/vim-snippets'
    " 很多虚拟终端不会发送<c-tab>以及<s-tab>到程序,所以应该避免映射这种按键
    " 插入模式下使用tab键插入代码片段
    let g:UltiSnipsExpandTrigger="<tab>"
    " 插入模式下使用s-tab键列出所有的可选片段供选择
    let g:UltiSnipsListSnippets="<s-tab>"
    " 在展开代码片段后使用tab键跳转需要修改的关键部分(如果有的话)
    let g:UltiSnipsJumpForwardTrigger="<tab>"
    " 类似上面的定义,但是反向移动
    let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
    " 可以使用:UltiSnipsEdit命令自定义供补全的代码片段,其保存到下面指定的目录下
    let g:UltiSnipsSnippetsDir = '~/.vim/UltiSnips'
    " 当使用:UltiSnipsEdit命令时在一个垂直新建的窗口中编写
    let g:UltiSnipsEditSplit="vertical"


"##############
" ale
" 异步检查代码插件
Plug 'w0rp/ale', { 'for': ['dosbatch','sh','zsh','python','go'] }
    " 用于检查python的工具, pylint
    " python2:pylint2, python3:pylint3
    let g:ale_python_pylint_executable = 'pylint3'

    " 启动golang语法检查
    let g:ale_linters = {
        \ 'go' : ['gometalinter', 'gofmt'],
        \ 'zsh' : ['shellcheck']
        \ }

    " 修改默认的提示符颜色
    " 使用:highlight-link查看link子命令的帮助
    hi link ALEErrorSign ErrorMsg
    hi link ALEWarningSign WarningMsg
    " 强制ale进行语法检查(没什么必要)
    nnoremap <leader>ac :ALELint<cr>


"##############
" vim-fswitch
" c/cpp头文件切换
Plug 'derekwyatt/vim-fswitch', { 'for': ['c','cpp'] }
    map <f4> :FSHere<cr>


"##############
" YouCompleteMe
" 一个多功能的自动补全插件
" 支持c系列,python,go,TypeScript,JavaScript,rust语言补全,
" 支持文件目录/文件名补全
" 支持从vim的omnifunc接收数据补全
" 支持上下文变量以及tags文件补全
" 支持UltiSnips的snippet补全(一个快速插入整块代码的插件)
" 异常强大,但需要手动编译,编译的时候可以选择性的编译上述特性
" 需要注意的是如果vim-plug更新了YCM,那么就有可能需要重新编译
Plug 'Valloric/YouCompleteMe', { 'for': ['java','c','cpp','dosbatch','sh','zsh','python','html','xhtml','go','javascript'] }
" 为YCM生成ycm_extra_conf文件
Plug 'rdnetto/YCM-Generator', { 'branch': 'stable', 'for': ['java','c','cpp','dosbatch','sh','python','html','xhtml','go'] }
    " 只需要输入一个字符就触发补全
    let g:ycm_min_num_of_chars_for_completion = 1
    " 当没有找到打开的文件或项目的'.ycm_extra_conf.py'时使用哪个作为默认的
    let g:ycm_global_ycm_extra_conf = '~/dotfiles/ycm_extra_conf-default.py'
    " 加载自定义'.ycm_extra_conf.py'不再询问
    let g:ycm_confirm_extra_conf = 0
    " 使用ctrl-j或下键或ctrl-n在补全菜单中向下移动
    let g:ycm_key_list_select_completion = ['<C-N>']
    " 使用ctrl-k或上键或ctrl-p在补全菜单中向上移动
    let g:ycm_key_list_previous_completion = ['<C-P>']
    " 编辑注释时也自动补全
    let g:ycm_complete_in_comments = 1
    " 从注释和字符串中收集可补全关键字
    let g:ycm_collect_identifiers_from_comments_and_strings = 1
    " 将补全项的详细信息放入预览窗口中
    let g:ycm_add_preview_to_completeopt = 1
    " 当接受补全项之后关闭预览窗口
    "let g:ycm_autoclose_preview_window_after_completion = 1
    " 当离开插入模式后,自动关闭用于显示补全项详细信息的预览窗口(上面的选项启用时这个选项可能无效)
    "let g:ycm_autoclose_preview_window_after_insertion = 1
    " 当使用下面定义的GoTo*系列快捷键时使用垂直分割打开新窗口显示数据
    "let g:ycm_goto_buffer_command = 'vertical-split'
    " 指定ycmd使用的py版本, 必须是编译ycm时所用的以及vim支持的py版本
    let g:ycm_server_python_interpreter = 'python3'
    " 指定ycm client使用的python版本(也是jedi使用的python版本)
    let g:ycm_python_binary_path = 'python3'
    " ycm语法检查相关的功能,此功能目前(2019-04-07)支持以下语言：
    " C-family, C#, Java, JavaScript, TypeScript
    " 注意此功能有可能与其他语法检查插件冲突如：syntastic，ale
    " 如果要关闭ycm的语法检查功能就取消注释下面这行配置
    "let g:ycm_show_diagnostics_ui = 0
    " 自动将错误信息放入位置列表
    let g:ycm_always_populate_location_list = 1
    " 语法错误或警告时使用的提示字符
    let g:ycm_error_symbol = ">>"
    let g:ycm_warning_symbol = "??"
    " 定义上述提示字符的颜色(默认的看着不舒服)
    " 此处没有重新定义颜色组,而是使用了已定义好的"ErrorMsg"或"WarningMsg"组
    highlight link YcmErrorSign ErrorMsg
    highlight link YcmWarningSign ErrorMsg

    " 以下映射对应命令生效的对象一般是光标下的变量或者方法
    " 不是所有命令适用于所有语言，具体是否支持应该查阅 YCM 的 README
    " 跳转到头文件
    nnoremap <leader>gi :YcmCompleter GoToInclude<CR>
    " 跳转到声明
    nnoremap <leader>gdc :YcmCompleter GoToDeclaration<CR>
    " 跳转到定义
    nnoremap <leader>gdf :YcmCompleter GoToDefinition<CR>
    " 跳转到声明或定义
    nnoremap <leader>gg :YcmCompleter GoTo<CR>
    " 跳转到引用
    nnoremap <leader>grf :YcmCompleter GoToReferences<CR>
    " 获取类型信息
    nnoremap <leader>gt :YcmCompleter GetType<CR>
    " 获取父类信息
    nnoremap <leader>gp :YcmCompleter GetParent<CR>
    " 获取相关文档
    nnoremap <leader>go :YcmCompleter GetDoc<CR>
    " 快速修复检测到的语法错误
    nnoremap <leader>gf :YcmCompleter FixIt<CR>
    " 重构之重命名
    nnoremap <leader>grr :YcmCompleter RefactorRename 
    " 强制进行语法检查
    nnoremap <leader>gc :YcmForceCompileAndDiagnostics<CR>
    " 打开错误位置列表窗口
    nnoremap <leader>ge :YcmDiags<CR>


"############
" vim-quickrun
" 快速运行当前文件或选中的行
Plug 'thinca/vim-quickrun', { 'for': ['sh','java','c','cpp','python','go'] }
    " 按F5按默认配置快速启动
    nmap <F5> <Plug>(quickrun)
    " 为了避免运行时无法进行交互
    " 所以设置runner为shell, 默认为system
    let g:quickrun_config = {
    \   "_" : {
    \       "runner" : "shell",
    \   },
    \}



"######
" tagbar
" 以对象的方式显示当前文件中的类，变量，方法，等
Plug 'majutsushi/tagbar', { 'for': ['vim','java','c','cpp','python','go'] }
    " 默认按照tag在文件中出现的顺序排序，在tagbar中按s可临时改为使用名字排序
    let g:tagbar_sort = 0
    " 按<F8>开关tag窗口
    nnoremap <F8> :TagbarToggle<CR><C-W>b
    nnoremap <leader>t :TagbarShowTag<CR>

    " 增加对于golang的支持(方法1)
    " 需要安装外部工具: go get -u github.com/jstemmer/gotags
    " 使用go安装gotags,安装完成之后可执行文件gotags一般在$HOME/go/bin目录下,需将其加入$PATH环境变量中
    let g:tagbar_type_go = {
        \ 'ctagstype' : 'go',
        \ 'kinds'     : [
            \ 'p:package',
            \ 'i:imports:1',
            \ 'c:constants',
            \ 'v:variables',
            \ 't:types',
            \ 'n:interfaces',
            \ 'w:fields',
            \ 'e:embedded',
            \ 'm:methods',
            \ 'r:constructor',
            \ 'f:functions'
        \ ],
        \ 'sro' : '.',
        \ 'kind2scope' : {
            \ 't' : 'ctype',
            \ 'n' : 'ntype'
        \ },
        \ 'scope2kind' : {
            \ 'ctype' : 't',
            \ 'ntype' : 'n'
        \ },
        \ 'ctagsbin'  : 'gotags',
        \ 'ctagsargs' : '-sort -silent'
    \ }

    " 增加对于golang的支持(方法2)
    " 这种方法依赖debian系列的exuberant-ctags包(已经包含了对于golang的tag支持补丁)
    " 这种方式虽然简单但是不支持作用于支持, 推荐上一种方式
"    let g:tagbar_type_go = {
"        \ 'ctagstype': 'go',
"        \ 'kinds' : [
"            \'p:package',
"            \'f:function',
"            \'v:variables',
"            \'t:type',
"            \'c:const'
"        \]
"    \}



"##############
" vim-qt-assistant
" 打开 qt assistant
Plug 'listenerri/vim-qt-assistant', { 'for': ['cpp'] }
    noremap <f1> :call GetDocFromAssistant()<cr>



"##############
" vim-easygrep
Plug 'listenerri/vim-easygrep', { 'branch': 'ag-recursive-switch' }
    " 使用grepprg选项指定的外部命令搜索
    "set grepprg=ack
    set grepprg=ag\ -U\ $*
    let g:EasyGrepCommand = 1
    " 设置使用替换命令Replace时的窗口模式
    let g:EasyGrepReplaceWindowMode = 2
    " 哪些文件或目录需要排除
    let g:EasyGrepFilesToExclude = ".svn,.git,build"
    " 默认递归搜索
    let g:EasyGrepRecursive = 1
    " 在结果中列出同一行的多个匹配项
    let g:EasyGrepEveryMatch = 1
    " 不自动跳转到第一个匹配项
    let g:EasyGrepJumpToMatch = 0
    " 结果列表窗口在哪里出现
    let EasyGrepWindowPosition = "rightbelow"
    " 快速设置EasyGrep选项的前缀(默认是'<leader>vy')
    " 按下前缀后再按一个代表对应选项的字母就可以切换该选项(如递归,大小写等)
    " 具体有哪些字母(选项)可以打开选项列表查看(在选项列表中按?显示更多选项)
    let g:EasyGrepOptionPrefix = '<leader>fs'
    " 打开选项列表(options list)
    nmap <leader>fl <plug>EgMapGrepOptions
    " 下面的按键含有大写的表示搜索时使用'whole word'模式
    " vnoremap的表示在可视模式下搜索选择的内容
    " nnoremap的表示搜索光标下的单词
    " f: 搜索并将结果展示在列表中
    " a: 搜索并将结果追加在列表中
    " r: 搜索并替换(交互模式)
    nmap <leader>ff <plug>EgMapGrepCurrentWord_v
    vmap <leader>ff <plug>EgMapGrepSelection_v
    nmap <leader>fF <plug>EgMapGrepCurrentWord_V
    vmap <leader>fF <plug>EgMapGrepSelection_V
    nmap <leader>fa <plug>EgMapGrepCurrentWord_a
    vmap <leader>fa <plug>EgMapGrepSelection_a
    nmap <leader>fA <plug>EgMapGrepCurrentWord_A
    vmap <leader>fA <plug>EgMapGrepSelection_A
    nmap <leader>fr <plug>EgMapReplaceCurrentWord_r
    vmap <leader>fr <plug>EgMapReplaceSelection_r
    nmap <leader>fR <plug>EgMapReplaceCurrentWord_R
    vmap <leader>fR <plug>EgMapReplaceSelection_R


" NERD-Commenter
" 提供注释功能
Plug 'scrooloose/nerdcommenter', { 'for': ['vim','java','c','cpp','dosbatch','sh','python','html','xhtml','go'] }
    map <c-_> <plug>NERDCommenterToggle


" qt相关插件
" qt语法高亮
Plug 'kosl90/qt-highlight-vim'
" qmake语法高亮
Plug 'vim-scripts/qmake--syntax.vim'
    " 设置类似pro，pri等文件的filetype为qmake，以激活这个语法高亮插件
    au BufReadPost *.pr? setfiletype qmake


" git 插件
Plug 'tpope/vim-fugitive'


" DoxygenToolkit.vim
" doxygen文档注释插件
Plug 'vim-scripts/DoxygenToolkit.vim', { 'for': ['c','cpp','python'] }
    let g:DoxygenToolkit_briefTag_pre = "\\brief "
    let g:DoxygenToolkit_templateParamTag_pre = "\\tparam "
    let g:DoxygenToolkit_paramTag_pre = "\\param "
    let g:DoxygenToolkit_returnTag = "\\return "
    let g:DoxygenToolkit_throwTag_pre = "\\throw " " @exception is also valid
    let g:DoxygenToolkit_fileTag = "\\file "
    let g:DoxygenToolkit_authorTag = "\\author "
    let g:DoxygenToolkit_dateTag = "\\date "
    let g:DoxygenToolkit_versionTag = "\\version "
    let g:DoxygenToolkit_blockTag = "\\name "
    let g:DoxygenToolkit_classTag = "\\class "

    " 添加两个命令用于中英文标记
    command! -nargs=0 Doe :call DoxygenCommentFuncEnglish()
    command! -nargs=0 Doc :call DoxygenCommentFuncChinese()

    function! DoxygenCommentFuncEnglish()
        let g:DoxygenToolkit_interCommentTag = "* \\~english "
        let g:DoxygenToolkit_interCommentBlock = "* \\~english "
        Dox
    endfunction

    function! DoxygenCommentFuncChinese()
        let g:DoxygenToolkit_interCommentTag = "* \\~chinese "
        let g:DoxygenToolkit_interCommentBlock = "* \\~chinese "
        Dox
    endfunction
